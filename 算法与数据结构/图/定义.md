## 图的环检测BFS版

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAX = 1e5 + 5;
vector<int> adj[MAX];
bool vis[MAX];

bool isCyclic(int s, int n) {
    // 初始化队列和访问标记
    queue<pair<int, int>> q;
    memset(vis, false, sizeof(vis));

    // 把起点加入队列并标记已访问
    q.push({s, -1});
    vis[s] = true;

    while (!q.empty()) {
        int u = q.front().first;
        int parent = q.front().second;
        q.pop();

        // 遍历所有邻接点
        for (int v : adj[u]) {
            // 如果邻接点未被访问过,把它加入队列并标记已访问
            if (!vis[v]) {
                q.push({v, u});
                vis[v] = true;
            }
            // 如果邻接点已被访问过,且不是当前点的父节点,说明存在环
            else if (v != parent)
                return true;
        }
    }

    // 没有找到环
    return false;
}

int main() {
    int n, m;
    cin >> n >> m;

    // 构建无向图
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // 检测是否存在环
    bool hasCycle = false;
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            if (isCyclic(i, n)) {
                hasCycle = true;
                break;
            }
        }
    }

    if (hasCycle)
        cout << "Graph contains cycle\n";
    else
        cout << "Graph doesn't contain cycle\n";

    return 0;
}
```

## 图的环检测DFS版

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAX = 1e5 + 5;
vector<int> adj[MAX];
bool vis[MAX];
bool recStack[MAX];

bool isCyclicUtil(int u, int n) {
    // 标记当前节点已被访问并放入递归栈
    vis[u] = true;
    recStack[u] = true;

    // 遍历所有邻接点
    for (int v : adj[u]) {
        // 如果邻接点在递归栈中,说明存在环
        if (recStack[v])
            return true;

        // 如果邻接点未被访问过,继续向下递归
        if (!vis[v])
            if (isCyclicUtil(v, n))
                return true;
    }

    // 当前节点处理完毕,从递归栈中移除
    recStack[u] = false;
    return false;
}

bool isCyclic(int n) {
    // 初始化访问标记和递归栈标记
    memset(vis, false, sizeof(vis));
    memset(recStack, false, sizeof(recStack));

    // 遍历所有未访问的节点
    for (int i = 1; i <= n; i++)
        if (!vis[i])
            if (isCyclicUtil(i, n))
                return true;

    // 没有找到环
    return false;
}

int main() {
    int n, m;
    cin >> n >> m;

    // 构建无向图
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // 检测是否存在环
    if (isCyclic(n))
        cout << "Graph contains cycle\n";
    else
        cout << "Graph doesn't contain cycle\n";

    return 0;
}
```