# 进程创建

- `alloc_task_struct_node`: 分配一个task_struct结构
- `alloc_thread_stack_node`: 创建内核栈
- `arch_dup_task_struct`: 复制task_struct
- `setup_thread_stack`: 设置thread_info
- `prepare_creds`: 分配新的`struct cred`，然后调用memcpy复制父进程的cred
- `sched_fork`: 设置调度相关的变量, 包括调度实体、进程状态、优先级、设置该进程的调度类
- `task_fork`: 调用调度类的task_fork函数，进行初始化
- `copy_files`: 复制一个进程打开的文件信息，调用dup_fd, 创建一个新的files_struct, 然后将所有的文件描述符数组fdtable拷贝一份
- `copy_fs`: 复制一个进程的目录信息，包括根目录、根文件系统，当前目录、当前目录的文件系统
- `copy_sighand`: 维护信号处理函数
- `copy_signal`: 维护发送给该进程的信号
- `copy_mm`: 复制进程内存空间，复制mm_struct结构
- 设置pid、tid、group_leader，建立进程之间的亲缘关系

## 进程唤醒

> 详情查看进程调度章节

## 线程创建

> 线程是由内核态和用户态合作完成的，在内核态中线程与进程都是task_struct结构

在用户态维护线程的结构是pthread，每个线程有自己的栈，通过`allocate_stack`分配线程的栈

> 线程栈是在进程的堆里面创建的

调用clone之后，内核态有一个与当前线程对应的`task_struct`，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程要执行的那个函数

内核态在处理clone的时候，与前面复制进程逻辑一样

- 对于`file_struct`, `fs_struct`, `sighand_struct`, `signal_struct`, `mm_struct`都是进行引用计数加一或者直接返回。
- 亲缘关系设置: group_leader, tgid,可以用来判断线程属于哪一个进程